/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.openkruise.client.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubernetes.client.custom.IntOrString;
import io.openkruise.client.models.KruiseAppsV1alpha1CloneSetSpecUpdateStrategyPriorityStrategy;
import io.openkruise.client.models.KruiseAppsV1alpha1CloneSetSpecUpdateStrategyScatterStrategy;
import io.openkruise.client.models.KruiseAppsV1alpha1SidecarSetSpecUpdateStrategySelector;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * The sidecarset updateStrategy to use to replace existing pods with new ones.
 */
@ApiModel(description = "The sidecarset updateStrategy to use to replace existing pods with new ones.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2023-07-21T15:55:09.049+08:00")
public class KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy {
  @SerializedName("maxUnavailable")
  private IntOrString maxUnavailable = null;

  @SerializedName("partition")
  private IntOrString partition = null;

  @SerializedName("paused")
  private Boolean paused = null;

  @SerializedName("priorityStrategy")
  private KruiseAppsV1alpha1CloneSetSpecUpdateStrategyPriorityStrategy priorityStrategy = null;

  @SerializedName("scatterStrategy")
  private List<KruiseAppsV1alpha1CloneSetSpecUpdateStrategyScatterStrategy> scatterStrategy = null;

  @SerializedName("selector")
  private KruiseAppsV1alpha1SidecarSetSpecUpdateStrategySelector selector = null;

  @SerializedName("type")
  private String type = null;

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy maxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
    return this;
  }

   /**
   * The maximum number of SidecarSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of SidecarSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.
   * @return maxUnavailable
  **/
  @ApiModelProperty(value = "The maximum number of SidecarSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of SidecarSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.")
  public IntOrString getMaxUnavailable() {
    return maxUnavailable;
  }

  public void setMaxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
  }

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy partition(IntOrString partition) {
    this.partition = partition;
    return this;
  }

   /**
   * Partition is the desired number of pods in old revisions. It means when partition is set during pods updating, (replicas - partition) number of pods will be updated. Default value is 0.
   * @return partition
  **/
  @ApiModelProperty(value = "Partition is the desired number of pods in old revisions. It means when partition is set during pods updating, (replicas - partition) number of pods will be updated. Default value is 0.")
  public IntOrString getPartition() {
    return partition;
  }

  public void setPartition(IntOrString partition) {
    this.partition = partition;
  }

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy paused(Boolean paused) {
    this.paused = paused;
    return this;
  }

   /**
   * Paused indicates that the SidecarSet is paused to update the injected pods, but it don&#39;t affect the webhook inject sidecar container into the newly created pods. default is false
   * @return paused
  **/
  @ApiModelProperty(value = "Paused indicates that the SidecarSet is paused to update the injected pods, but it don't affect the webhook inject sidecar container into the newly created pods. default is false")
  public Boolean isPaused() {
    return paused;
  }

  public void setPaused(Boolean paused) {
    this.paused = paused;
  }

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy priorityStrategy(KruiseAppsV1alpha1CloneSetSpecUpdateStrategyPriorityStrategy priorityStrategy) {
    this.priorityStrategy = priorityStrategy;
    return this;
  }

   /**
   * Get priorityStrategy
   * @return priorityStrategy
  **/
  @ApiModelProperty(value = "")
  public KruiseAppsV1alpha1CloneSetSpecUpdateStrategyPriorityStrategy getPriorityStrategy() {
    return priorityStrategy;
  }

  public void setPriorityStrategy(KruiseAppsV1alpha1CloneSetSpecUpdateStrategyPriorityStrategy priorityStrategy) {
    this.priorityStrategy = priorityStrategy;
  }

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy scatterStrategy(List<KruiseAppsV1alpha1CloneSetSpecUpdateStrategyScatterStrategy> scatterStrategy) {
    this.scatterStrategy = scatterStrategy;
    return this;
  }

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy addScatterStrategyItem(KruiseAppsV1alpha1CloneSetSpecUpdateStrategyScatterStrategy scatterStrategyItem) {
    if (this.scatterStrategy == null) {
      this.scatterStrategy = new ArrayList<KruiseAppsV1alpha1CloneSetSpecUpdateStrategyScatterStrategy>();
    }
    this.scatterStrategy.add(scatterStrategyItem);
    return this;
  }

   /**
   * ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.
   * @return scatterStrategy
  **/
  @ApiModelProperty(value = "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.")
  public List<KruiseAppsV1alpha1CloneSetSpecUpdateStrategyScatterStrategy> getScatterStrategy() {
    return scatterStrategy;
  }

  public void setScatterStrategy(List<KruiseAppsV1alpha1CloneSetSpecUpdateStrategyScatterStrategy> scatterStrategy) {
    this.scatterStrategy = scatterStrategy;
  }

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy selector(KruiseAppsV1alpha1SidecarSetSpecUpdateStrategySelector selector) {
    this.selector = selector;
    return this;
  }

   /**
   * Get selector
   * @return selector
  **/
  @ApiModelProperty(value = "")
  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategySelector getSelector() {
    return selector;
  }

  public void setSelector(KruiseAppsV1alpha1SidecarSetSpecUpdateStrategySelector selector) {
    this.selector = selector;
  }

  public KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Type is NotUpdate, the SidecarSet don&#39;t update the injected pods, it will only inject sidecar container into the newly created pods. Type is RollingUpdate, the SidecarSet will update the injected pods to the latest version on RollingUpdate Strategy. default is RollingUpdate
   * @return type
  **/
  @ApiModelProperty(value = "Type is NotUpdate, the SidecarSet don't update the injected pods, it will only inject sidecar container into the newly created pods. Type is RollingUpdate, the SidecarSet will update the injected pods to the latest version on RollingUpdate Strategy. default is RollingUpdate")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy = (KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy) o;
    return Objects.equals(this.maxUnavailable, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.maxUnavailable) &&
        Objects.equals(this.partition, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.partition) &&
        Objects.equals(this.paused, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.paused) &&
        Objects.equals(this.priorityStrategy, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.priorityStrategy) &&
        Objects.equals(this.scatterStrategy, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.scatterStrategy) &&
        Objects.equals(this.selector, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.selector) &&
        Objects.equals(this.type, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxUnavailable, partition, paused, priorityStrategy, scatterStrategy, selector, type);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy {\n");
    
    sb.append("    maxUnavailable: ").append(toIndentedString(maxUnavailable)).append("\n");
    sb.append("    partition: ").append(toIndentedString(partition)).append("\n");
    sb.append("    paused: ").append(toIndentedString(paused)).append("\n");
    sb.append("    priorityStrategy: ").append(toIndentedString(priorityStrategy)).append("\n");
    sb.append("    scatterStrategy: ").append(toIndentedString(scatterStrategy)).append("\n");
    sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

