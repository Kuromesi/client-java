/*
 * Kruise
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.openkruise.client.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubernetes.client.custom.IntOrString;
import io.openkruise.client.models.KruiseAppsPubInPlaceUpdateStrategy;
import io.openkruise.client.models.KruiseAppsPubUpdatePriorityStrategy;
import io.openkruise.client.models.KruiseAppsV1alpha1UpdateScatterTerm;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * CloneSetUpdateStrategy defines strategies for pods update.
 */
@ApiModel(description = "CloneSetUpdateStrategy defines strategies for pods update.")

public class KruiseAppsV1alpha1CloneSetUpdateStrategy {
  @SerializedName("inPlaceUpdateStrategy")
  private KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy = null;

  @SerializedName("maxSurge")
  private IntOrString maxSurge = null;

  @SerializedName("maxUnavailable")
  private IntOrString maxUnavailable = null;

  @SerializedName("partition")
  private IntOrString partition = null;

  @SerializedName("paused")
  private Boolean paused = null;

  @SerializedName("priorityStrategy")
  private KruiseAppsPubUpdatePriorityStrategy priorityStrategy = null;

  @SerializedName("scatterStrategy")
  private List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy = null;

  @SerializedName("type")
  private String type = null;

  public KruiseAppsV1alpha1CloneSetUpdateStrategy inPlaceUpdateStrategy(KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy) {
    this.inPlaceUpdateStrategy = inPlaceUpdateStrategy;
    return this;
  }

   /**
   * InPlaceUpdateStrategy contains strategies for in-place update.
   * @return inPlaceUpdateStrategy
  **/
  @ApiModelProperty(value = "InPlaceUpdateStrategy contains strategies for in-place update.")
  public KruiseAppsPubInPlaceUpdateStrategy getInPlaceUpdateStrategy() {
    return inPlaceUpdateStrategy;
  }

  public void setInPlaceUpdateStrategy(KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy) {
    this.inPlaceUpdateStrategy = inPlaceUpdateStrategy;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy maxSurge(IntOrString maxSurge) {
    this.maxSurge = maxSurge;
    return this;
  }

   /**
   * The maximum number of pods that can be scheduled above the desired replicas during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.
   * @return maxSurge
  **/
  @ApiModelProperty(value = "The maximum number of pods that can be scheduled above the desired replicas during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.")
  public IntOrString getMaxSurge() {
    return maxSurge;
  }

  public void setMaxSurge(IntOrString maxSurge) {
    this.maxSurge = maxSurge;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy maxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
    return this;
  }

   /**
   * The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge &gt; 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.
   * @return maxUnavailable
  **/
  @ApiModelProperty(value = "The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.")
  public IntOrString getMaxUnavailable() {
    return maxUnavailable;
  }

  public void setMaxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy partition(IntOrString partition) {
    this.partition = partition;
    return this;
  }

   /**
   * Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.
   * @return partition
  **/
  @ApiModelProperty(value = "Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.")
  public IntOrString getPartition() {
    return partition;
  }

  public void setPartition(IntOrString partition) {
    this.partition = partition;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy paused(Boolean paused) {
    this.paused = paused;
    return this;
  }

   /**
   * Paused indicates that the CloneSet is paused. Default value is false
   * @return paused
  **/
  @ApiModelProperty(value = "Paused indicates that the CloneSet is paused. Default value is false")
  public Boolean isPaused() {
    return paused;
  }

  public void setPaused(Boolean paused) {
    this.paused = paused;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy priorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
    this.priorityStrategy = priorityStrategy;
    return this;
  }

   /**
   * Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.
   * @return priorityStrategy
  **/
  @ApiModelProperty(value = "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.")
  public KruiseAppsPubUpdatePriorityStrategy getPriorityStrategy() {
    return priorityStrategy;
  }

  public void setPriorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
    this.priorityStrategy = priorityStrategy;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy scatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
    this.scatterStrategy = scatterStrategy;
    return this;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy addScatterStrategyItem(KruiseAppsV1alpha1UpdateScatterTerm scatterStrategyItem) {
    if (this.scatterStrategy == null) {
      this.scatterStrategy = new ArrayList<KruiseAppsV1alpha1UpdateScatterTerm>();
    }
    this.scatterStrategy.add(scatterStrategyItem);
    return this;
  }

   /**
   * ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.
   * @return scatterStrategy
  **/
  @ApiModelProperty(value = "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.")
  public List<KruiseAppsV1alpha1UpdateScatterTerm> getScatterStrategy() {
    return scatterStrategy;
  }

  public void setScatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
    this.scatterStrategy = scatterStrategy;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.
   * @return type
  **/
  @ApiModelProperty(value = "Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KruiseAppsV1alpha1CloneSetUpdateStrategy kruiseAppsV1alpha1CloneSetUpdateStrategy = (KruiseAppsV1alpha1CloneSetUpdateStrategy) o;
    return Objects.equals(this.inPlaceUpdateStrategy, kruiseAppsV1alpha1CloneSetUpdateStrategy.inPlaceUpdateStrategy) &&
        Objects.equals(this.maxSurge, kruiseAppsV1alpha1CloneSetUpdateStrategy.maxSurge) &&
        Objects.equals(this.maxUnavailable, kruiseAppsV1alpha1CloneSetUpdateStrategy.maxUnavailable) &&
        Objects.equals(this.partition, kruiseAppsV1alpha1CloneSetUpdateStrategy.partition) &&
        Objects.equals(this.paused, kruiseAppsV1alpha1CloneSetUpdateStrategy.paused) &&
        Objects.equals(this.priorityStrategy, kruiseAppsV1alpha1CloneSetUpdateStrategy.priorityStrategy) &&
        Objects.equals(this.scatterStrategy, kruiseAppsV1alpha1CloneSetUpdateStrategy.scatterStrategy) &&
        Objects.equals(this.type, kruiseAppsV1alpha1CloneSetUpdateStrategy.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(inPlaceUpdateStrategy, maxSurge, maxUnavailable, partition, paused, priorityStrategy, scatterStrategy, type);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KruiseAppsV1alpha1CloneSetUpdateStrategy {\n");
    
    sb.append("    inPlaceUpdateStrategy: ").append(toIndentedString(inPlaceUpdateStrategy)).append("\n");
    sb.append("    maxSurge: ").append(toIndentedString(maxSurge)).append("\n");
    sb.append("    maxUnavailable: ").append(toIndentedString(maxUnavailable)).append("\n");
    sb.append("    partition: ").append(toIndentedString(partition)).append("\n");
    sb.append("    paused: ").append(toIndentedString(paused)).append("\n");
    sb.append("    priorityStrategy: ").append(toIndentedString(priorityStrategy)).append("\n");
    sb.append("    scatterStrategy: ").append(toIndentedString(scatterStrategy)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

