/*
 * Kruise
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.openkruise.client.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import org.joda.time.DateTime;
import io.openkruise.client.models.KruiseAppsV1alpha1WorkloadSpreadSubsetCondition;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * WorkloadSpreadSubsetStatus defines the observed state of subset
 */
@ApiModel(description = "WorkloadSpreadSubsetStatus defines the observed state of subset")

public class KruiseAppsV1alpha1WorkloadSpreadSubsetStatus {
  @SerializedName("conditions")
  private List<KruiseAppsV1alpha1WorkloadSpreadSubsetCondition> conditions = null;

  @SerializedName("creatingPods")
  private Map<String, DateTime> creatingPods = null;

  @SerializedName("deletingPods")
  private Map<String, DateTime> deletingPods = null;

  @SerializedName("missingReplicas")
  private Integer missingReplicas = 0;

  @SerializedName("name")
  private String name = "";

  @SerializedName("replicas")
  private Integer replicas = 0;

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus conditions(List<KruiseAppsV1alpha1WorkloadSpreadSubsetCondition> conditions) {
    this.conditions = conditions;
    return this;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus addConditionsItem(KruiseAppsV1alpha1WorkloadSpreadSubsetCondition conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<KruiseAppsV1alpha1WorkloadSpreadSubsetCondition>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * Conditions is an array of current observed subset conditions.
   * @return conditions
  **/
  @ApiModelProperty(value = "Conditions is an array of current observed subset conditions.")
  public List<KruiseAppsV1alpha1WorkloadSpreadSubsetCondition> getConditions() {
    return conditions;
  }

  public void setConditions(List<KruiseAppsV1alpha1WorkloadSpreadSubsetCondition> conditions) {
    this.conditions = conditions;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus creatingPods(Map<String, DateTime> creatingPods) {
    this.creatingPods = creatingPods;
    return this;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus putCreatingPodsItem(String key, DateTime creatingPodsItem) {
    if (this.creatingPods == null) {
      this.creatingPods = new HashMap<String, DateTime>();
    }
    this.creatingPods.put(key, creatingPodsItem);
    return this;
  }

   /**
   * CreatingPods contains information about pods whose creation was processed by the webhook handler but not yet been observed by the WorkloadSpread controller. A pod will be in this map from the time when the webhook handler processed the creation request to the time when the pod is seen by controller. The key in the map is the name of the pod and the value is the time when the webhook handler process the creation request. If the real creation didn&#39;t happen and a pod is still in this map, it will be removed from the list automatically by WorkloadSpread controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod creations.
   * @return creatingPods
  **/
  @ApiModelProperty(value = "CreatingPods contains information about pods whose creation was processed by the webhook handler but not yet been observed by the WorkloadSpread controller. A pod will be in this map from the time when the webhook handler processed the creation request to the time when the pod is seen by controller. The key in the map is the name of the pod and the value is the time when the webhook handler process the creation request. If the real creation didn't happen and a pod is still in this map, it will be removed from the list automatically by WorkloadSpread controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod creations.")
  public Map<String, DateTime> getCreatingPods() {
    return creatingPods;
  }

  public void setCreatingPods(Map<String, DateTime> creatingPods) {
    this.creatingPods = creatingPods;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus deletingPods(Map<String, DateTime> deletingPods) {
    this.deletingPods = deletingPods;
    return this;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus putDeletingPodsItem(String key, DateTime deletingPodsItem) {
    if (this.deletingPods == null) {
      this.deletingPods = new HashMap<String, DateTime>();
    }
    this.deletingPods.put(key, deletingPodsItem);
    return this;
  }

   /**
   * DeletingPods is similar with CreatingPods and it contains information about pod deletion.
   * @return deletingPods
  **/
  @ApiModelProperty(value = "DeletingPods is similar with CreatingPods and it contains information about pod deletion.")
  public Map<String, DateTime> getDeletingPods() {
    return deletingPods;
  }

  public void setDeletingPods(Map<String, DateTime> deletingPods) {
    this.deletingPods = deletingPods;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus missingReplicas(Integer missingReplicas) {
    this.missingReplicas = missingReplicas;
    return this;
  }

   /**
   * MissingReplicas is the number of active replicas belong to this subset not be found. MissingReplicas &gt; 0 indicates the subset is still missing MissingReplicas pods to create MissingReplicas &#x3D; 0 indicates the subset already has enough pods, there is no need to create MissingReplicas &#x3D; -1 indicates the subset&#39;s MaxReplicas not set, then there is no limit for pods number
   * @return missingReplicas
  **/
  @ApiModelProperty(required = true, value = "MissingReplicas is the number of active replicas belong to this subset not be found. MissingReplicas > 0 indicates the subset is still missing MissingReplicas pods to create MissingReplicas = 0 indicates the subset already has enough pods, there is no need to create MissingReplicas = -1 indicates the subset's MaxReplicas not set, then there is no limit for pods number")
  public Integer getMissingReplicas() {
    return missingReplicas;
  }

  public void setMissingReplicas(Integer missingReplicas) {
    this.missingReplicas = missingReplicas;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name should be unique between all of the subsets under one WorkloadSpread.
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Name should be unique between all of the subsets under one WorkloadSpread.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public KruiseAppsV1alpha1WorkloadSpreadSubsetStatus replicas(Integer replicas) {
    this.replicas = replicas;
    return this;
  }

   /**
   * Replicas is the most recently observed number of active replicas for subset.
   * @return replicas
  **/
  @ApiModelProperty(required = true, value = "Replicas is the most recently observed number of active replicas for subset.")
  public Integer getReplicas() {
    return replicas;
  }

  public void setReplicas(Integer replicas) {
    this.replicas = replicas;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KruiseAppsV1alpha1WorkloadSpreadSubsetStatus kruiseAppsV1alpha1WorkloadSpreadSubsetStatus = (KruiseAppsV1alpha1WorkloadSpreadSubsetStatus) o;
    return Objects.equals(this.conditions, kruiseAppsV1alpha1WorkloadSpreadSubsetStatus.conditions) &&
        Objects.equals(this.creatingPods, kruiseAppsV1alpha1WorkloadSpreadSubsetStatus.creatingPods) &&
        Objects.equals(this.deletingPods, kruiseAppsV1alpha1WorkloadSpreadSubsetStatus.deletingPods) &&
        Objects.equals(this.missingReplicas, kruiseAppsV1alpha1WorkloadSpreadSubsetStatus.missingReplicas) &&
        Objects.equals(this.name, kruiseAppsV1alpha1WorkloadSpreadSubsetStatus.name) &&
        Objects.equals(this.replicas, kruiseAppsV1alpha1WorkloadSpreadSubsetStatus.replicas);
  }

  @Override
  public int hashCode() {
    return Objects.hash(conditions, creatingPods, deletingPods, missingReplicas, name, replicas);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KruiseAppsV1alpha1WorkloadSpreadSubsetStatus {\n");
    
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    creatingPods: ").append(toIndentedString(creatingPods)).append("\n");
    sb.append("    deletingPods: ").append(toIndentedString(deletingPods)).append("\n");
    sb.append("    missingReplicas: ").append(toIndentedString(missingReplicas)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

